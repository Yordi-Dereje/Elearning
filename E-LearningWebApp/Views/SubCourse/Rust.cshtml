@*
    For more information on enabling MVC for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860
*@
@{
    Layout = "UserLayout";
}
<main>
    <div id="partitions">
        <div class="partition">
            <h2>Rust Programming Language</h2>
            <p>
                Rust is a systems programming language that emphasizes safety, performance, and concurrency. It was designed to be a "safe, concurrent, and practical language," supporting both functional and imperative-procedural paradigms.
            </p>
        </div>

        <div class="partition">
            <h2>Ownership and Borrowing</h2>
            <p>
                One of Rust's key features is ownership, a system that enables memory safety without garbage collection.
            </p>
            <p>
                Ownership rules:
            </p>
            <ul>
                <li>Each value in Rust has a variable that is its "owner".</li>
                <li>There can only be one owner at a time.</li>
                <li>When the owner goes out of scope, the value will be dropped.</li>
            </ul>
            <p>
                Example code:
            </p>
            <code>
                fn main() {
                let s1 = String::from("Hello");
                let s2 = s1; // Ownership moves from s1 to s2
                // println!("{}", s1); // This line would cause an error since s1 is no longer valid
                println!("{}", s2); // This is valid
                }
            </code>
        </div>

        <div class="partition">
            <h2>References and Borrowing</h2>
            <p>
                To allow multiple parts of the code to access the data without taking ownership, Rust introduces borrowing.
            </p>
            <p>
                Reference rules:
            </p>
            <ul>
                <li>References do not have ownership.</li>
                <li>References must always be valid.</li>
                <li>Only one mutable reference is allowed in a particular scope.</li>
            </ul>
            <p>
                Example code:
            </p>
            <code>
                fn main() {
                let s1 = String::from("Hello");
                let len = calculate_length(&s1); // Pass a reference to s1
                println!("The length of '{}' is {}.", s1, len);
                }

                fn calculate_length(s: &String) -> usize {
                s.len()
                }
            </code>
        </div>

        <div class="partition">
            <h2>Lifetimes</h2>
            <p>
                Lifetimes are annotations that indicate how long references live. They help prevent dangling references.
            </p>
            <p>
                Lifetime rules:
            </p>
            <ul>
                <li>Every reference has a lifetime.</li>
                <li>Lifetimes are a way of specifying the scope for which a reference is valid.</li>
            </ul>
            <p>
                Example code:
            </p>
            <code>
                fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
                if s1.len() > s2.len() {
                s1
                } else {
                s2
                }
                }
            </code>
        </div>

        <div class="partition">
            <h2>Structs and Enums</h2>
            <p>
                Rust provides structs for creating custom data types with named fields and enums for defining enumerations.
            </p>
            <p>
                Example code:
            </p>
            <code>
                struct Point {
                x: i32,
                y: i32,
                }

                enum Shape {
                Circle(f64),
                Rectangle(f64, f64),
                Triangle(f64, f64, f64),
                }
            </code>
        </div>

        <div class="partition">
            <h2>Pattern Matching</h2>
            <p>
                Pattern matching in Rust is done through the match keyword, allowing for concise and expressive code.
            </p>
            <p>
                Example code:
            </p>
            <code>
                fn print_shape_area(shape: Shape) {
                match shape {
                Shape::Circle(radius) => println!("Area of circle: {}", 3.14 * radius * radius),
                Shape::Rectangle(width, height) => println!("Area of rectangle: {}", width * height),
                Shape::Triangle(a, b, c) => {
                let s = (a + b + c) / 2.0;
                let area = (s * (s - a) * (s - b) * (s - c)).sqrt();
                println!("Area of triangle: {}", area);
                }
                }
                }
            </code>
        </div>

        <div class="partition">
            <h2>Error Handling</h2>
            <p>
                Rust uses the Result enum for error handling. Functions can return a Result with either Ok(value) or Err(error).
            </p>
            <p>
                Example code:
            </p>
            <code>
                fn parse_number(s: &str) -> Result<i32, ParseIntError>
                    {
                    s.parse::<i32>
                        ()
                        }

                        fn main() {
                        let result = parse_number("42");
                        match result {
                        Ok(num) => println!("Parsed number: {}", num),
                        Err(err) => println!("Error: {:?}", err),
                        }
                        }
            </code>
        </div>

        <div class="partition">
            <h2>Concurrency</h2>
            <p>
                Rust provides built-in concurrency support with threads and the ownership system ensures thread safety.
            </p>
            <p>
                Example code:
            </p>
            <code>
                use std::thread;
                use std::time::Duration;

                fn main() {
                let handle = thread::spawn(|| {
                for i in 1..5 {
                println!("Thread: {}", i);
                thread::sleep(Duration::from_millis(500));
                }
                });

                for i in 1..3 {
                println!("Main thread: {}", i);
                thread::sleep(Duration::from_millis(1000));
                }

                handle.join().unwrap();
                }
            </code>
        </div>

        <div class="partition">
            <h2>Unsafe Rust</h2>
            <p>
                Rust allows unsafe code within blocks marked with the 'unsafe' keyword. This is often used for low-level operations.
            </p>
            <p>
                Example code:
            </p>
            <code>
                unsafe {
                println!("This is unsafe code.");
                }
            </code>
        </div>

        <div class="partition">
            <h2>Cargo - Rust Package Manager</h2>
            <p>
                Cargo is Rust's package manager and is used for managing Rust projects, including building, testing, and dependencies.
            </p>
            <p>
                Example commands:
            </p>
            <code>
                // Create a new Rust project
                cargo new my_project

                // Build the project
                cargo build

                // Run tests
                cargo test

                // Build and run the project
                cargo run
            </code>
        </div>

        <div class="partition">
            <h2>Conclusion</h2>
            <p>
                Rust is a powerful language that combines performance with safety. Its ownership system, borrowing, and lifetime concepts make it unique and effective for systems programming. With a growing ecosystem and an active community, Rust continues to gain popularity for a wide range of applications.
            </p>
        </div>
    </div>


</main>